# ColorCard é¡¹ç›®æ¶æ„è®¾è®¡æ·±åº¦æ•™ç¨‹

## ğŸ“š ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æŠ€æœ¯æ ˆåˆ†æ](#æŠ€æœ¯æ ˆåˆ†æ)
3. [æ¶æ„è®¾è®¡åŸåˆ™](#æ¶æ„è®¾è®¡åŸåˆ™)
4. [ç›®å½•ç»“æ„è¯¦è§£](#ç›®å½•ç»“æ„è¯¦è§£)
5. [æ ¸å¿ƒç³»ç»Ÿæ·±åº¦åˆ†æ](#æ ¸å¿ƒç³»ç»Ÿæ·±åº¦åˆ†æ)
6. [çŠ¶æ€ç®¡ç†æ¶æ„](#çŠ¶æ€ç®¡ç†æ¶æ„)
7. [æœåŠ¡å±‚è®¾è®¡](#æœåŠ¡å±‚è®¾è®¡)
8. [åŒæ¸²æŸ“ç³»ç»Ÿ](#åŒæ¸²æŸ“ç³»ç»Ÿ)
9. [æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ](#æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ)
10. [åŠ¨ç”»ç³»ç»Ÿ](#åŠ¨ç”»ç³»ç»Ÿ)
11. [é¢œè‰²ç®¡ç†ç³»ç»Ÿ](#é¢œè‰²ç®¡ç†ç³»ç»Ÿ)
12. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
13. [è·¨å¹³å°é€‚é…](#è·¨å¹³å°é€‚é…)
14. [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)

---

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

ColorCard æ˜¯ä¸€ä¸ªåŸºäºç°ä»£ Web æŠ€æœ¯æ ˆæ„å»ºçš„è·¨å¹³å°é¢œè‰²ç®¡ç†åº”ç”¨ï¼Œä¸»è¦ç‰¹è‰²åŒ…æ‹¬ï¼š

- **æ™ºèƒ½åŒæ¸²æŸ“ç³»ç»Ÿ**ï¼šæ ¹æ®çº¹ç†å¤æ‚åº¦æ™ºèƒ½é€‰æ‹© Canvas æˆ– CSS æ¸²æŸ“
- **å…ˆè¿›çŠ¶æ€ç®¡ç†**ï¼šåŸºäº Zustand çš„æ¨¡å—åŒ–çŠ¶æ€æ¶æ„
- **ä¸°å¯Œäº¤äº’ä½“éªŒ**ï¼šæ‰‹åŠ¿æ§åˆ¶ã€è§¦è§‰åé¦ˆã€æµç•…åŠ¨ç”»
- **å®Œæ•´æœåŠ¡å±‚**ï¼šæŠ½è±¡åŒ–çš„å¹³å°æœåŠ¡ã€å­˜å‚¨æœåŠ¡ã€åŠ¨ç”»æœåŠ¡
- **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶æ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œä¼˜åŒ–å»ºè®®

### æ ¸å¿ƒåŠŸèƒ½
- ğŸ“± è·¨å¹³å°é¢œè‰²å±•ç¤ºå’Œç®¡ç†
- ğŸ¨ å¤šç§æè´¨çº¹ç†æ•ˆæœï¼ˆçº¯è‰²ã€æ¸å˜ã€ç‰çŸ³ã€æ¯›ç»ç’ƒç­‰ï¼‰
- ğŸŒˆ ä¸°å¯Œé¢œè‰²åˆ†ç±»ï¼ˆå“ç‰Œè‰²ã€ä¸­å›½ä¼ ç»Ÿè‰²ã€è‡ªç„¶è‰²ç­‰ï¼‰
- ğŸ“¸ é«˜è´¨é‡å£çº¸æˆªå›¾ç”Ÿæˆ
- âš¡ æµç•…æ‰‹åŠ¿äº¤äº’å’ŒåŠ¨ç”»è¿‡æ¸¡

---

## ğŸ”§ æŠ€æœ¯æ ˆåˆ†æ

### å‰ç«¯æ¡†æ¶å±‚
```typescript
// æ ¸å¿ƒæ¡†æ¶
React 18.2.0           // ç°ä»£åŒ–ç»„ä»¶å¼€å‘
Ionic React 8.0.0      // ç§»åŠ¨ç«¯UIç»„ä»¶åº“
TypeScript 5.1.6       // ç±»å‹å®‰å…¨ä¿éšœ

// çŠ¶æ€ç®¡ç†
Zustand 5.0.2          // è½»é‡çº§çŠ¶æ€ç®¡ç†åº“

// åŠ¨ç”»ç³»ç»Ÿ
React Spring 9.7.5     // ç‰©ç†åŠ¨ç”»åº“
@use-gesture/react     // æ‰‹åŠ¿è¯†åˆ«åº“
```

### è·¨å¹³å°å±‚
```typescript
// ç§»åŠ¨ç«¯é€‚é…
Capacitor 6.2.0        // åŸç”ŸåŠŸèƒ½æ¡¥æ¥
@capacitor/haptics     // è§¦è§‰åé¦ˆ
@capacitor/filesystem  // æ–‡ä»¶ç³»ç»Ÿè®¿é—®
@capacitor/preferences // æ•°æ®æŒä¹…åŒ–
```

### 3Dæ¸²æŸ“å±‚
```typescript
// 3Då›¾å½¢æ¸²æŸ“
Babylon.js 7.41.1      // 3Dæ¸²æŸ“å¼•æ“
@babylonjs/materials   // æè´¨ç³»ç»Ÿ
@babylonjs/loaders     // èµ„æºåŠ è½½
```

### æ ·å¼ç³»ç»Ÿ
```typescript
// æ ·å¼å¤„ç†
SCSS                   // æ ·å¼é¢„å¤„ç†å™¨
Tailwind CSS 3.4.17   // åŸå­åŒ–CSSæ¡†æ¶
PostCSS 8.4.49         // CSSåå¤„ç†å™¨
```

### å·¥ç¨‹åŒ–å·¥å…·
```typescript
// æ„å»ºå·¥å…·
Vite 5.4.19           // ç°ä»£åŒ–æ„å»ºå·¥å…·
Vitest 0.34.6         // å•å…ƒæµ‹è¯•æ¡†æ¶
Cypress 13.5.0        // E2Eæµ‹è¯•æ¡†æ¶
ESLint 8.35.0         // ä»£ç æ£€æŸ¥å·¥å…·
```

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡åŸåˆ™

### 1. åˆ†å±‚æ¶æ„åŸåˆ™
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI Components â”‚  â† çº¯å±•ç¤ºå±‚ï¼Œè´Ÿè´£æ¸²æŸ“
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Containers    â”‚  â† å®¹å™¨å±‚ï¼Œä¸šåŠ¡é€»è¾‘ç»„åˆ
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Hooks Layer   â”‚  â† é€»è¾‘æŠ½è±¡å±‚ï¼Œå¯å¤ç”¨ä¸šåŠ¡é€»è¾‘
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Services      â”‚  â† æœåŠ¡å±‚ï¼Œå¤–éƒ¨ä¾èµ–æŠ½è±¡
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   State Store   â”‚  â† çŠ¶æ€å±‚ï¼Œå…¨å±€çŠ¶æ€ç®¡ç†
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ¨¡å—åŒ–åŸåˆ™
- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸ
- **æ¾è€¦åˆ**ï¼šæ¨¡å—é—´é€šè¿‡æ¥å£é€šä¿¡ï¼Œå‡å°‘ç›´æ¥ä¾èµ–
- **é«˜å†…èš**ï¼šç›¸å…³åŠŸèƒ½é›†ä¸­åœ¨åŒä¸€æ¨¡å—å†…

### 3. å¯æ‰©å±•æ€§åŸåˆ™
- **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
- **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡é…ç½®æ³¨å…¥ä¾èµ–ï¼Œä¾¿äºæµ‹è¯•å’Œæ‰©å±•
- **æ’ä»¶åŒ–æ¶æ„**ï¼šæ ¸å¿ƒåŠŸèƒ½å¯é€šè¿‡æ’ä»¶æ‰©å±•

---

## ğŸ“ ç›®å½•ç»“æ„è¯¦è§£

```
src/
â”œâ”€â”€ components/          # ğŸ§© UIç»„ä»¶å±‚
â”‚   â”œâ”€â”€ features/       # åŠŸèƒ½ç»„ä»¶ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰
â”‚   â”‚   â”œâ”€â”€ ColorGrid.tsx
â”‚   â”‚   â”œâ”€â”€ SaveButton.tsx
â”‚   â”‚   â””â”€â”€ TextureToolbar.tsx
â”‚   â”œâ”€â”€ ui/             # é€šç”¨UIç»„ä»¶
â”‚   â”œâ”€â”€ lazy/           # æ‡’åŠ è½½ç»„ä»¶
â”‚   â””â”€â”€ ErrorBoundary.tsx
â”‚
â”œâ”€â”€ containers/         # ğŸ—ï¸ å®¹å™¨ç»„ä»¶å±‚
â”‚   â””â”€â”€ HomeContainer.tsx  # ä¸»é¡µé¢å®¹å™¨
â”‚
â”œâ”€â”€ hooks/              # ğŸª è‡ªå®šä¹‰Hookså±‚
â”‚   â”œâ”€â”€ business/       # ä¸šåŠ¡é€»è¾‘Hooks
â”‚   â”‚   â”œâ”€â”€ useColorSelection.ts
â”‚   â”‚   â”œâ”€â”€ useTextureManagement.ts
â”‚   â”‚   â””â”€â”€ useWallpaperGeneration.ts
â”‚   â”œâ”€â”€ ui/             # UIç›¸å…³Hooks
â”‚   â”‚   â”œâ”€â”€ useGestureHandler.ts
â”‚   â”‚   â””â”€â”€ usePageTransition.ts
â”‚   â””â”€â”€ utils/          # å·¥å…·Hooks
â”‚       â”œâ”€â”€ useDebounce.ts
â”‚       â””â”€â”€ useThrottle.ts
â”‚
â”œâ”€â”€ services/           # ğŸ”§ æœåŠ¡å±‚
â”‚   â”œâ”€â”€ animation/      # åŠ¨ç”»æœåŠ¡
â”‚   â”œâ”€â”€ storage/        # å­˜å‚¨æœåŠ¡
â”‚   â”œâ”€â”€ platform/       # å¹³å°æœåŠ¡
â”‚   â””â”€â”€ monitoring/     # æ€§èƒ½ç›‘æ§æœåŠ¡
â”‚
â”œâ”€â”€ stores/             # ğŸ—„ï¸ çŠ¶æ€ç®¡ç†å±‚
â”‚   â”œâ”€â”€ slices/         # ZustandçŠ¶æ€åˆ‡ç‰‡
â”‚   â”‚   â”œâ”€â”€ colorSlice.ts
â”‚   â”‚   â”œâ”€â”€ textureSlice.ts
â”‚   â”‚   â””â”€â”€ appSlice.ts
â”‚   â””â”€â”€ useAppStore.ts  # ä¸»å­˜å‚¨å…¥å£
â”‚
â”œâ”€â”€ config/             # âš™ï¸ é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ brandColors.ts  # å“ç‰Œè‰²é…ç½®
â”‚   â”œâ”€â”€ textureConfig.ts # çº¹ç†é…ç½®
â”‚   â””â”€â”€ tabConfig.ts    # æ ‡ç­¾é¡µé…ç½®
â”‚
â”œâ”€â”€ utils/              # ğŸ› ï¸ å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ backgroundUtils.ts
â”‚   â”œâ”€â”€ screenshot.ts
â”‚   â””â”€â”€ logger.ts
â”‚
â”œâ”€â”€ types/              # ğŸ“ ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ index.ts
â”‚
â””â”€â”€ styles/             # ğŸ¨ æ ·å¼æ–‡ä»¶
    â”œâ”€â”€ _variables.scss
    â”œâ”€â”€ _mixins.scss
    â””â”€â”€ main.scss
```

### æ¶æ„å±‚çº§è¯´æ˜

#### ğŸ“± UI Components Layerï¼ˆUIç»„ä»¶å±‚ï¼‰
**èŒè´£**ï¼šçº¯å±•ç¤ºç»„ä»¶ï¼Œæ¥æ”¶propsæ¸²æŸ“UIï¼Œä¸åŒ…å«ä¸šåŠ¡é€»è¾‘

```typescript
// ç¤ºä¾‹ï¼šSaveButton.tsx
interface SaveButtonProps {
  onSave: () => void;
  isLoading: boolean;
  disabled?: boolean;
}

const SaveButton: React.FC<SaveButtonProps> = ({ onSave, isLoading, disabled }) => {
  return (
    <button 
      onClick={onSave}
      disabled={disabled || isLoading}
      className="save-button"
    >
      {isLoading ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜å£çº¸'}
    </button>
  );
};
```

#### ğŸ—ï¸ Container Layerï¼ˆå®¹å™¨å±‚ï¼‰
**èŒè´£**ï¼šç»„åˆä¸šåŠ¡é€»è¾‘å’ŒUIç»„ä»¶ï¼Œå¤„ç†æ•°æ®æµå’Œäº‹ä»¶

```typescript
// ç¤ºä¾‹ï¼šHomeContainer.tsx
const HomeContainer: React.FC = () => {
  // ä¸šåŠ¡é€»è¾‘Hooks
  const { selectedColor, changeColor } = useColorSelection();
  const { saveWallpaper, isGenerating } = useWallpaperGeneration();
  const { gestureHandlers } = useGestureHandler();

  return (
    <div {...gestureHandlers}>
      <ColorCard color={selectedColor} />
      <SaveButton 
        onSave={saveWallpaper}
        isLoading={isGenerating}
      />
    </div>
  );
};
```

#### ğŸª Hooks Layerï¼ˆHookså±‚ï¼‰
**èŒè´£**ï¼šå°è£…å¯å¤ç”¨çš„ä¸šåŠ¡é€»è¾‘ï¼ŒçŠ¶æ€ç®¡ç†å’Œå‰¯ä½œç”¨å¤„ç†

```typescript
// ç¤ºä¾‹ï¼šuseColorSelection.ts
export const useColorSelection = () => {
  const { color, setColor, colorType, setColorType } = useAppStoreActions.useColorActions();
  
  const changeColor = useCallback((newColor: string) => {
    setColor(newColor);
    // è§¦è§‰åé¦ˆ
    PlatformService.triggerHapticFeedback(HapticFeedbackType.Light);
  }, [setColor]);

  return {
    selectedColor: color,
    colorType,
    changeColor,
    changeColorType: setColorType
  };
};
```

---

## ğŸ—„ï¸ çŠ¶æ€ç®¡ç†æ¶æ„

### Zustand æ¨¡å—åŒ–è®¾è®¡

ColorCard é‡‡ç”¨ Zustand ä½œä¸ºçŠ¶æ€ç®¡ç†åº“ï¼Œé€šè¿‡åˆ‡ç‰‡ï¼ˆsliceï¼‰æ¨¡å¼å®ç°æ¨¡å—åŒ–ç®¡ç†ï¼š

```typescript
// useAppStore.ts - ä¸»å­˜å‚¨æ–‡ä»¶
export interface AppStoreState extends ColorState, TextureState, AppState {
  resetStore: () => void;
  initializeStore: () => Promise<void>;
}

export const useAppStore = create<AppStoreState>()(
  devtools(
    subscribeWithSelector(
      (set, get, api) => ({
        // ç»„åˆæ‰€æœ‰çŠ¶æ€åˆ‡ç‰‡
        ...createColorSlice(set, get, api),
        ...createTextureSlice(set, get, api),
        ...createAppSlice(set, get, api),
        
        // å…¨å±€æ“ä½œæ–¹æ³•
        resetStore: () => { /* é‡ç½®é€»è¾‘ */ },
        initializeStore: async () => { /* åˆå§‹åŒ–é€»è¾‘ */ }
      })
    ),
    { name: 'color-card-store' }
  )
);
```

### çŠ¶æ€åˆ‡ç‰‡è®¾è®¡

#### 1. é¢œè‰²çŠ¶æ€åˆ‡ç‰‡ï¼ˆcolorSlice.tsï¼‰
```typescript
export interface ColorState {
  // å½“å‰çŠ¶æ€
  color: string;
  colorType: ColorType;
  
  // å†å²è®°å½•
  colorHistory: ColorHistoryItem[];
  favoriteColors: string[];
  
  // æ“ä½œæ–¹æ³•
  setColor: (color: string) => void;
  setColorType: (colorType: ColorType) => void;
  addToFavorites: (color: string) => void;
  
  // æŒä¹…åŒ–æ“ä½œ
  saveColorPreferences: () => Promise<void>;
  loadColorPreferences: () => Promise<void>;
}
```

**è®¾è®¡äº®ç‚¹**ï¼š
- **è‡ªåŠ¨æŒä¹…åŒ–**ï¼šçŠ¶æ€å˜æ›´æ—¶è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
- **å†å²è®°å½•ç®¡ç†**ï¼šæ™ºèƒ½å»é‡å’Œæ•°é‡é™åˆ¶
- **æ”¶è—åŠŸèƒ½**ï¼šæ”¯æŒé¢œè‰²æ”¶è—å’Œç®¡ç†

#### 2. çº¹ç†çŠ¶æ€åˆ‡ç‰‡ï¼ˆtextureSlice.tsï¼‰
```typescript
export interface TextureState {
  texture: TextureType;
  textureConfig: TextureConfig;
  textureHistory: TextureHistoryItem[];
  customPresets: TexturePreset[];
  
  // å·¥å…·æ–¹æ³•
  isCanvasTexture: (texture?: TextureType) => boolean;
  getTextureDisplayName: (texture: TextureType) => string;
}
```

**è®¾è®¡äº®ç‚¹**ï¼š
- **æ™ºèƒ½æ¸²æŸ“åˆ¤æ–­**ï¼šè‡ªåŠ¨åˆ¤æ–­æ˜¯å¦éœ€è¦Canvasæ¸²æŸ“
- **é¢„è®¾ç®¡ç†**ï¼šæ”¯æŒè‡ªå®šä¹‰çº¹ç†é¢„è®¾ä¿å­˜å’Œåº”ç”¨
- **é…ç½®ç³»ç»Ÿ**ï¼šçµæ´»çš„çº¹ç†å‚æ•°é…ç½®

#### 3. åº”ç”¨çŠ¶æ€åˆ‡ç‰‡ï¼ˆappSlice.tsï¼‰
```typescript
export interface AppState {
  debug: boolean;
  mode: AppMode;
  hideColorCard: boolean;
  isMinimized: boolean;
  isLoading: boolean;
  isTransitioning: boolean;
  
  // è®¾å¤‡ä¿¡æ¯
  isNativePlatform: boolean;
  deviceType: string;
}
```

### é€‰æ‹©å™¨æ¨¡å¼ä¼˜åŒ–

ä¸ºäº†é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“ï¼Œæä¾›äº†ä¼˜åŒ–çš„é€‰æ‹©å™¨ï¼š

```typescript
// æ€§èƒ½ä¼˜åŒ–çš„é€‰æ‹©å™¨
export const useAppStoreSelectors = {
  // å•ä¸€å±æ€§é€‰æ‹©å™¨
  useColor: () => useAppStore(state => state.color),
  useTexture: () => useAppStore(state => state.texture),
  
  // ç»„åˆé€‰æ‹©å™¨
  useCurrentSelection: () => useAppStore(state => ({
    color: state.color,
    texture: state.texture,
    colorType: state.colorType,
    textureConfig: state.textureConfig
  })),
  
  // UIçŠ¶æ€é€‰æ‹©å™¨
  useUIState: () => useAppStore(state => ({
    isLoading: state.isLoading,
    isTransitioning: state.isTransitioning,
    isMinimized: state.isMinimized
  }))
};
```

---

## ğŸ”§ æœåŠ¡å±‚è®¾è®¡

æœåŠ¡å±‚æ˜¯ ColorCard æ¶æ„çš„æ ¸å¿ƒï¼Œè´Ÿè´£æŠ½è±¡å’Œå°è£…å¤–éƒ¨ä¾èµ–ï¼š

### 1. åŠ¨ç”»æœåŠ¡ï¼ˆAnimationServiceï¼‰

```typescript
export class AnimationService {
  // æ ‡å‡†åŠ¨ç”»é…ç½®é¢„è®¾
  static ANIMATION_CONFIGS = {
    quick: { tension: 300, friction: 30, mass: 0.8, clamp: true },
    standard: { tension: 280, friction: 60, mass: 1, clamp: true },
    smooth: { tension: 200, friction: 50, mass: 1, clamp: true }
  };

  // åˆ›å»ºé¡µé¢åˆ‡æ¢åŠ¨ç”»çŠ¶æ€
  static createPageTransitionState(
    phase: 'slideOut' | 'slideIn' | 'idle',
    direction: SlideDirection = 'left'
  ): { state: AnimationState; config: SpringConfig } {
    // åŠ¨ç”»çŠ¶æ€è®¡ç®—é€»è¾‘
  }
}
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- **æ ‡å‡†åŒ–é…ç½®**ï¼šé¢„å®šä¹‰åŠ¨ç”»å‚æ•°ï¼Œç¡®ä¿ä¸€è‡´çš„ç”¨æˆ·ä½“éªŒ
- **ç‰©ç†åŠ¨ç”»**ï¼šåŸºäº React Spring çš„ç‰©ç†åŠ¨ç”»å¼•æ“
- **ç»„åˆåŠ¨ç”»**ï¼šæ”¯æŒå¤æ‚åŠ¨ç”»åºåˆ—å’Œå¹¶è¡Œæ‰§è¡Œ

### 2. å­˜å‚¨æœåŠ¡ï¼ˆStorageServiceï¼‰

```typescript
export class StorageService {
  // è·¨å¹³å°å­˜å‚¨æŠ½è±¡
  static async saveUserPreferences(preferences: UserPreferences): Promise<void> {
    // ä½¿ç”¨ Capacitor Preferences API ç»Ÿä¸€å¤„ç†
    await Preferences.set({ key: STORAGE_KEYS.COLOR, value: preferences.color });
  }

  // æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
  static async saveFile(data: string, fileName: string): Promise<SaveResult> {
    if (!Capacitor.isNativePlatform()) {
      return this.saveFileWeb(data, fileName); // Webå¹³å°é™çº§å¤„ç†
    }
    // åŸç”Ÿå¹³å°æ–‡ä»¶ä¿å­˜
  }

  // ç¼“å­˜ç®¡ç†
  static async setCache(key: string, data: any, ttl?: number): Promise<void> {
    // å¸¦è¿‡æœŸæ—¶é—´çš„ç¼“å­˜ç³»ç»Ÿ
  }
}
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- **è·¨å¹³å°å…¼å®¹**ï¼šè‡ªåŠ¨é€‚é…Webå’ŒåŸç”Ÿå¹³å°å­˜å‚¨API
- **ç¼“å­˜ç³»ç»Ÿ**ï¼šæ”¯æŒTTLçš„æ™ºèƒ½ç¼“å­˜ç®¡ç†
- **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé™çº§æœºåˆ¶

### 3. å¹³å°æœåŠ¡ï¼ˆPlatformServiceï¼‰

```typescript
export class PlatformService {
  // å¹³å°èƒ½åŠ›æ£€æµ‹
  static async getCapabilities(): Promise<DeviceCapabilities> {
    return {
      platform: this.getPlatform(),
      deviceType: this.detectDeviceType(),
      isNative: this.isNative(),
      supportsHaptics: this.isNative(),
      hasNotch: this.detectNotch(),
      screenSize: { width, height, ratio },
      safeArea: { top, bottom, left, right }
    };
  }

  // è§¦è§‰åé¦ˆ
  static async triggerHapticFeedback(type: HapticFeedbackType): Promise<void> {
    if (!this.isNative()) return;
    
    switch (type) {
      case HapticFeedbackType.Light:
        await Haptics.impact({ style: ImpactStyle.Light });
        break;
      // å…¶ä»–åé¦ˆç±»å‹
    }
  }
}
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- **èƒ½åŠ›æ£€æµ‹**ï¼šåŠ¨æ€æ£€æµ‹è®¾å¤‡èƒ½åŠ›å’Œå¹³å°ç‰¹æ€§
- **ä¼˜é›…é™çº§**ï¼šWebå¹³å°è‡ªåŠ¨è·³è¿‡åŸç”ŸåŠŸèƒ½
- **è§¦è§‰åé¦ˆ**ï¼šä¸°å¯Œçš„è§¦è§‰åé¦ˆç±»å‹æ”¯æŒ

### 4. æ€§èƒ½ç›‘æ§æœåŠ¡ï¼ˆPerformanceServiceï¼‰

```typescript
export class PerformanceService {
  // Web Vitals ç›‘æ§
  private initWebVitalsMonitoring(): void {
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1] as any;
      if (lastEntry) {
        this.recordMetric({ LCP: lastEntry.startTime });
      }
    });
    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
  }

  // ç»„ä»¶æ¸²æŸ“æ€§èƒ½æµ‹é‡
  measureComponentRender<T>(componentName: string, renderFunction: () => T): T {
    const startTime = performance.now();
    const result = renderFunction();
    const endTime = performance.now();
    
    this.recordMetric({ componentRenderTime: endTime - startTime });
    return result;
  }
}
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- **å…¨é¢ç›‘æ§**ï¼šWeb Vitalsã€å†…å­˜ä½¿ç”¨ã€åŠ¨ç”»å¸§ç‡ç­‰
- **å®æ—¶åˆ†æ**ï¼šè‡ªåŠ¨ç”Ÿæˆæ€§èƒ½æŠ¥å‘Šå’Œä¼˜åŒ–å»ºè®®
- **è£…é¥°å™¨æ”¯æŒ**ï¼šé€šè¿‡è£…é¥°å™¨è‡ªåŠ¨æµ‹é‡å‡½æ•°æ€§èƒ½

---

## ğŸ¨ åŒæ¸²æŸ“ç³»ç»Ÿ

ColorCard çš„æ ¸å¿ƒåˆ›æ–°ä¹‹ä¸€æ˜¯æ™ºèƒ½åŒæ¸²æŸ“ç³»ç»Ÿï¼Œæ ¹æ®çº¹ç†å¤æ‚åº¦è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ¸²æŸ“æ–¹æ¡ˆï¼š

### æ¸²æŸ“ç­–ç•¥å†³ç­–

```typescript
// textureConfig.ts - çº¹ç†æ¸²æŸ“é…ç½®
export const textureConfigs: TextureConfig[] = [
  { type: 'solid', renderMode: 'div', enabled: true },      // CSSæ¸²æŸ“
  { type: 'linear', renderMode: 'div', enabled: true },     // CSSæ¸²æŸ“
  { type: 'paint', renderMode: 'canvas', enabled: true },   // Canvasæ¸²æŸ“
  { type: 'frosted', renderMode: 'div', enabled: true },    // CSSæ¸²æŸ“
  { type: 'leather', renderMode: 'canvas', enabled: false } // å¤æ‚çº¹ç†æš‚æ—¶ç¦ç”¨
];

// æ™ºèƒ½æ¸²æŸ“åˆ¤æ–­
export const getTextureConfig = (type: TextureType): TextureConfig | undefined => {
  return textureConfigs.find(config => config.type === type);
};
```

### CSSæ¸²æŸ“ç³»ç»Ÿï¼ˆDivBackground.tsxï¼‰

é€‚ç”¨äºç®€å•çº¹ç†ï¼Œæ€§èƒ½ä¼˜ç§€ï¼š

```typescript
const DivBackground: React.FC = () => {
  const color = useAppStore(state => state.color);
  const texture = useAppStore(state => state.texture);
  
  // è·å–çº¹ç†æ ·å¼
  const textureStyles = getTextureStyles({ texture, startColor: color });
  
  const finalStyles: React.CSSProperties = {
    position: 'absolute',
    top: 0, left: 0, right: 0, bottom: 0,
    width: '100%', height: '100%',
    zIndex: -1,
    transition: 'all 0.3s ease-in-out',
    backgroundColor: color,
    ...textureStyles // çº¹ç†æ ·å¼è¦†ç›–
  };

  return (
    <>
      <div style={backgroundImageStyle} />  {/* èƒŒæ™¯å›¾å±‚ */}
      <div style={finalStyles} />           {/* çº¹ç†å±‚ */}
    </>
  );
};
```

**çº¹ç†å®ç°ç¤ºä¾‹**ï¼š
```typescript
// divBackgroundUtils.ts
export const getTextureStyles = ({ texture, startColor }: TextureParams): React.CSSProperties => {
  switch (texture) {
    case 'linear':
      return {
        background: `linear-gradient(135deg, ${startColor} 0%, ${adjustBrightness(startColor, 20)} 100%)`
      };
      
    case 'frosted':
      return {
        background: startColor,
        backdropFilter: 'blur(20px) saturate(180%)',
        WebkitBackdropFilter: 'blur(20px) saturate(180%)',
        border: '1px solid rgba(255, 255, 255, 0.18)'
      };
      
    default:
      return {};
  }
};
```

### Canvasæ¸²æŸ“ç³»ç»Ÿï¼ˆCanvasBackground.tsxï¼‰

é€‚ç”¨äºå¤æ‚çº¹ç†ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼š

```typescript
const CanvasBackground: React.FC = () => {
  const color = useAppStoreSelectors.useColor();
  const texture = useAppStoreSelectors.useTexture();
  
  // Babylon.js åœºæ™¯åˆå§‹åŒ–
  useEffect(() => {
    const engine = new Engine(canvas, true, { 
      preserveDrawingBuffer: true,
      stencil: true,
      antialias: false, // æ€§èƒ½ä¼˜åŒ–
      adaptToDeviceRatio: false
    });

    const scene = new Scene(engine);
    setupScene(scene);
    setupCamera(scene);
    setupLights(scene);
    
    // åˆ›å»ºæ¸²æŸ“å¹³é¢
    const plane = MeshBuilder.CreatePlane('colorPlane', { size: 2 }, scene);
    
    // åº”ç”¨æè´¨
    updateMaterial();
    
    return () => {
      scene.dispose();
      engine.dispose();
    };
  }, []);
};
```

**æè´¨ç³»ç»Ÿ**ï¼š
```typescript
// canvasBackgroundUtils.ts
export const createMaterialByType = (scene: Scene, color: string, texture: TextureType): Material => {
  switch (texture) {
    case 'paint':
      return createJadeMaterial(scene, color);
    case 'glow':
      return createGlowMaterial(scene, color);
    default:
      return createStandardMaterial(scene, color);
  }
};

const createJadeMaterial = (scene: Scene, color: string): PBRMaterial => {
  const material = new PBRMaterial('jade', scene);
  material.baseColor = Color3.FromHexString(color);
  material.metallicFactor = 0.1;
  material.roughnessFactor = 0.3;
  material.alpha = 0.9;
  return material;
};
```

### æ¸²æŸ“ç³»ç»Ÿæ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | CSSæ¸²æŸ“ | Canvasæ¸²æŸ“ |
|------|---------|------------|
| **æ€§èƒ½** | ğŸŸ¢ ä¼˜ç§€ | ğŸŸ¡ è‰¯å¥½ |
| **åŠŸèƒ½** | ğŸŸ¡ åŸºç¡€ | ğŸŸ¢ å¼ºå¤§ |
| **å…¼å®¹æ€§** | ğŸŸ¢ å®Œç¾ | ğŸŸ¡ è‰¯å¥½ |
| **å†…å­˜å ç”¨** | ğŸŸ¢ ä½ | ğŸŸ¡ ä¸­ç­‰ |
| **å¼€å‘å¤æ‚åº¦** | ğŸŸ¢ ç®€å• | ğŸ”´ å¤æ‚ |

---

## ğŸ–±ï¸ æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ

### æ‰‹åŠ¿è¯†åˆ«æ¶æ„

```typescript
// useGestureHandler.ts
export const useGestureHandler = (
  elementRef: React.RefObject<HTMLElement>,
  onGesture: (event: GestureEvent) => void,
  config: GestureHandlerConfig = {}
): UseGestureHandlerReturn => {
  
  // æ‰‹åŠ¿ç±»å‹å®šä¹‰
  enum GestureType {
    SwipeLeft = 'swipe-left',
    SwipeRight = 'swipe-right',
    TwoFingerTap = 'two-finger-tap',
    RightClick = 'right-click'
  }
  
  // é˜²æŠ–æœºåˆ¶
  const [isGestureProcessing, setIsGestureProcessing] = useState(false);
  const debounceTimers = useRef<Map<GestureType, NodeJS.Timeout>>(new Map());
};
```

### æ»‘åŠ¨æ‰‹åŠ¿å®ç°

```typescript
const createSwipeGesture = useCallback(() => {
  return createGesture({
    el: elementRef.current,
    threshold: mergedConfig.swipe.threshold,
    gestureName: 'swipe-gesture',
    onMove: (detail) => {
      if (isGestureProcessing) return;
      
      const velocity = detail.velocityX;
      const delta = detail.deltaX;
      
      if (Math.abs(velocity) > 0.2 && Math.abs(delta) > 50) {
        const gestureType = velocity < 0 ? GestureType.SwipeLeft : GestureType.SwipeRight;
        triggerGestureEvent(gestureType, detail);
      }
    }
  });
}, [elementRef, isGestureProcessing, triggerGestureEvent]);
```

### è§¦è§‰åé¦ˆé›†æˆ

```typescript
const triggerGestureEvent = useCallback(async (type: GestureType, detail: GestureDetail) => {
  // é˜²æŠ–æ£€æŸ¥
  if (debounceTimers.current.has(type)) return;
  
  setIsGestureProcessing(true);
  
  // è§¦è§‰åé¦ˆ
  if (mergedConfig.swipe.enableHapticFeedback) {
    await PlatformService.triggerHapticFeedback(HapticFeedbackType.Light);
  }
  
  // è§¦å‘å›è°ƒ
  onGesture({ type, detail });
  
  // å»¶è¿Ÿé‡ç½®çŠ¶æ€
  setTimeout(() => setIsGestureProcessing(false), 500);
}, [mergedConfig, onGesture]);
```

### æ‰‹åŠ¿ä¸šåŠ¡é€»è¾‘

```typescript
// HomeContainer.tsx
const gestureHandlers = useGestureHandler(
  pageRef,
  (event: GestureEvent) => {
    switch (event.type) {
      case GestureType.SwipeLeft:
        switchToNextColorType();
        break;
      case GestureType.SwipeRight:
        switchToPrevColorType();
        break;
      case GestureType.TwoFingerTap:
      case GestureType.RightClick:
        toggleMinimized();
        break;
    }
  },
  {
    swipe: { 
      threshold: 15, 
      debounceTime: 500,
      enableHapticFeedback: true 
    }
  }
);
```

---

## ğŸ¬ åŠ¨ç”»ç³»ç»Ÿ

### React Spring é›†æˆ

ColorCard ä½¿ç”¨ React Spring ä½œä¸ºåŠ¨ç”»å¼•æ“ï¼Œæä¾›ç‰©ç†çœŸå®çš„åŠ¨ç”»æ•ˆæœï¼š

```typescript
// usePageTransition.ts
export const usePageTransition = (): UsePageTransitionReturn => {
  const [springProps, api] = useSpring(() => ({
    opacity: 1,
    transform: 'translateX(0%) translateY(0%)',
    config: ANIMATION_CONFIGS.smooth
  }));

  const startTransition = useCallback(async (direction: SlideDirection, onComplete?: () => void) => {
    // ç¬¬ä¸€é˜¶æ®µï¼šæ»‘å‡ºåŠ¨ç”»
    const slideOutState = AnimationService.createPageTransitionState('slideOut', direction);
    await api.start({...slideOutState.state, config: slideOutState.config});

    // æ‰§è¡Œå†…å®¹åˆ‡æ¢
    if (onComplete) onComplete();

    // ç¬¬äºŒé˜¶æ®µï¼šæ»‘å…¥åŠ¨ç”»
    const slideInState = AnimationService.createPageTransitionState('slideIn', direction);
    await api.start({...slideInState.state, config: slideInState.config});
  }, [api]);
};
```

### åŠ¨ç”»é…ç½®ç³»ç»Ÿ

```typescript
// AnimationService.ts
export const ANIMATION_CONFIGS = {
  // å¿«é€Ÿå“åº” - æŒ‰é’®ç‚¹å‡»ç­‰å³æ—¶åé¦ˆ
  quick: {
    tension: 300, friction: 30, mass: 0.8, clamp: true
  },
  
  // æ ‡å‡†åŠ¨ç”» - ä¸€èˆ¬UIè¿‡æ¸¡
  standard: {
    tension: 280, friction: 60, mass: 1, clamp: true
  },
  
  // å¹³æ»‘åŠ¨ç”» - é¡µé¢åˆ‡æ¢ç­‰é‡è¦è¿‡æ¸¡
  smooth: {
    tension: 200, friction: 50, mass: 1, clamp: true
  }
};
```

### æ‰‹åŠ¿å“åº”åŠ¨ç”»

```typescript
// æ‰‹åŠ¿è·ŸéšåŠ¨ç”»
const startGestureTransition = useCallback((direction: SlideDirection, progress: number) => {
  const transformValue = progress * 100;
  const transformDirection = direction === 'left' ? -transformValue : transformValue;
  
  api.start({
    opacity: Math.max(0.3, 1 - progress * 0.7),
    transform: `translateX(${transformDirection}%)`,
    config: AnimationService.getGestureAnimationConfig(),
    immediate: true // ç«‹å³å“åº”æ‰‹åŠ¿
  });
}, [api]);
```

### åŠ¨ç”»æ€§èƒ½ä¼˜åŒ–

1. **ç¡¬ä»¶åŠ é€Ÿ**ï¼šæ‰€æœ‰åŠ¨ç”»éƒ½ä½¿ç”¨ transform å’Œ opacity
2. **å¸§ç‡ç›‘æ§**ï¼šå®æ—¶ç›‘æ§åŠ¨ç”»å¸§ç‡ï¼Œä½äº30fpsæ—¶å‘å‡ºè­¦å‘Š
3. **åŠ¨ç”»é™çº§**ï¼šä½ç«¯è®¾å¤‡è‡ªåŠ¨é™çº§åˆ°ç®€å•åŠ¨ç”»

---

## ğŸŒˆ é¢œè‰²ç®¡ç†ç³»ç»Ÿ

### é¢œè‰²åˆ†ç±»ä½“ç³»

```typescript
// å“ç‰Œè‰²ç³» - Pantone å¹´åº¦ä»£è¡¨è‰²
export const colorCards: ColorCard[] = [
  {
    color: '#FF6F61',
    name: 'Living Coral',
    zhName: 'æ´»çŠç‘šæ©˜',
    pinyin: 'huÃ³ shÄn hÃº jÃº',
    rgb: '255, 111, 97',
    cmyk: '0, 56, 62, 0',
    description: 'å……æ»¡æ´»åŠ›ä¸ç”Ÿå‘½åŠ›çš„çŠç‘šè‰²è°ƒï¼Œè±¡å¾ç€è‡ªç„¶çš„æ¸©æš–ä¸æ»‹å…»',
    year: 2019
  }
  // ... æ›´å¤šé¢œè‰²
];

// ä¸­å›½ä¼ ç»Ÿè‰²ç³»
export const chineseColors: ColorCard[] = [
  {
    color: '#E4C6D0',
    name: 'è—•è·ç²‰',
    zhName: 'è—•è·è‰²',
    pinyin: 'Ç’u hÃ© sÃ¨',
    description: 'æµ…ç´«è‰²ä¸æµ…çº¢è‰²ä¹‹é—´çš„é¢œè‰²'
  }
  // ... æ›´å¤šä¼ ç»Ÿè‰²
];
```

### é¢œè‰²å·¥å…·å‡½æ•°

```typescript
// backgroundUtils.ts
export const getContrastColor = (hexColor: string): string => {
  const rgb = hexToRgb(hexColor);
  const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  return brightness > 128 ? '#000000' : '#FFFFFF';
};

export const adjustBrightness = (hexColor: string, percent: number): string => {
  const rgb = hexToRgb(hexColor);
  return rgbToHex({
    r: Math.min(255, Math.max(0, rgb.r + (rgb.r * percent / 100))),
    g: Math.min(255, Math.max(0, rgb.g + (rgb.g * percent / 100))),
    b: Math.min(255, Math.max(0, rgb.b + (rgb.b * percent / 100)))
  });
};
```

### é¢œè‰²çŠ¶æ€ç®¡ç†

```typescript
// colorSlice.ts
export const createColorSlice: StateCreator<ColorState> = (set, get) => ({
  color: '#ff6b6b',
  colorType: 'brand',
  colorHistory: [],
  favoriteColors: [],

  setColor: (color: string) => {
    set({ color });
    
    // è‡ªåŠ¨æ·»åŠ åˆ°å†å²è®°å½•
    const { addToColorHistory, colorType } = get();
    addToColorHistory(color, colorType);
    
    // è‡ªåŠ¨ä¿å­˜åå¥½è®¾ç½®
    get().saveColorPreferences();
  },

  addToColorHistory: (color: string, colorType: ColorType) => {
    const { colorHistory } = get();
    
    // å»é‡å¹¶é™åˆ¶æ•°é‡
    const existingIndex = colorHistory.findIndex(item => item.color === color);
    const newItem = { color, colorType, timestamp: Date.now() };
    
    let updatedHistory: ColorHistoryItem[];
    if (existingIndex >= 0) {
      updatedHistory = [newItem, ...colorHistory.filter((_, index) => index !== existingIndex)];
    } else {
      updatedHistory = [newItem, ...colorHistory];
    }
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (updatedHistory.length > 50) {
      updatedHistory = updatedHistory.slice(0, 50);
    }
    
    set({ colorHistory: updatedHistory });
  }
});
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç»„ä»¶çº§ä¼˜åŒ–

#### React.memo ä½¿ç”¨
```typescript
// çº¯å±•ç¤ºç»„ä»¶ä½¿ç”¨ memo
const ColorCard = React.memo<ColorCardProps>(({ color, name, description }) => {
  return (
    <div className="color-card" style={{ backgroundColor: color }}>
      <h3>{name}</h3>
      <p>{description}</p>
    </div>
  );
});

// æ¯”è¾ƒå‡½æ•°ä¼˜åŒ–
const ColorGrid = React.memo(ColorGridComponent, (prevProps, nextProps) => {
  return prevProps.colors === nextProps.colors && 
         prevProps.selectedColor === nextProps.selectedColor;
});
```

#### useCallback å’Œ useMemo
```typescript
const HomeContainer: React.FC = () => {
  const colors = useAppStoreSelectors.useCurrentColors();
  
  // æ˜‚è´µè®¡ç®—ä½¿ç”¨ useMemo
  const filteredColors = useMemo(() => {
    return colors.filter(color => color.enabled);
  }, [colors]);
  
  // äº‹ä»¶å¤„ç†ä½¿ç”¨ useCallback
  const handleColorSelect = useCallback((color: string) => {
    setColor(color);
    triggerHapticFeedback();
  }, [setColor]);
  
  return <ColorGrid colors={filteredColors} onSelect={handleColorSelect} />;
};
```

### 2. æ¸²æŸ“ä¼˜åŒ–

#### æ™ºèƒ½æ¸²æŸ“åˆ‡æ¢
```typescript
// æ ¹æ®è®¾å¤‡æ€§èƒ½é€‰æ‹©æ¸²æŸ“æ–¹æ¡ˆ
const BackgroundRenderer: React.FC = () => {
  const texture = useAppStoreSelectors.useTexture();
  const performanceLevel = PlatformService.getPerformanceLevel();
  
  const renderMode = useMemo(() => {
    const config = getTextureConfig(texture);
    if (!config) return 'div';
    
    // ä½ç«¯è®¾å¤‡å¼ºåˆ¶ä½¿ç”¨ CSS æ¸²æŸ“
    if (performanceLevel <= 2 && config.renderMode === 'canvas') {
      return 'div';
    }
    
    return config.renderMode;
  }, [texture, performanceLevel]);
  
  return renderMode === 'canvas' ? <CanvasBackground /> : <DivBackground />;
};
```

#### Canvas æ¸²æŸ“ä¼˜åŒ–
```typescript
// Canvas å¼•æ“é…ç½®ä¼˜åŒ–
const engine = new Engine(canvas, true, { 
  preserveDrawingBuffer: true,
  stencil: true,
  antialias: false,           // å…³é—­æŠ—é”¯é½¿æé«˜æ€§èƒ½
  adaptToDeviceRatio: false,  // å›ºå®šåˆ†è¾¨ç‡
  powerPreference: 'default'  // å¹³è¡¡æ€§èƒ½å’ŒåŠŸè€—
});

// åœºæ™¯ä¼˜åŒ–
scene.skipPointerMovePicking = true;  // ç¦ç”¨æŒ‡é’ˆç§»åŠ¨æ‹¾å–
scene.autoClear = true;               // å¯ç”¨è‡ªåŠ¨æ¸…é™¤
```

### 3. å†…å­˜ç®¡ç†

#### èµ„æºæ¸…ç†
```typescript
useEffect(() => {
  const engine = new Engine(canvas, true, options);
  const scene = new Scene(engine);
  
  // æ¸²æŸ“å¾ªç¯ä¼˜åŒ–
  engine.runRenderLoop(() => {
    if (scene.activeCamera) {
      scene.render();
    }
  });
  
  // æ¸…ç†å‡½æ•°
  return () => {
    engine.stopRenderLoop();
    scene.dispose();          // æ¸…ç†åœºæ™¯èµ„æº
    engine.dispose();         // æ¸…ç†å¼•æ“èµ„æº
  };
}, []);
```

#### é˜²æŠ–å’ŒèŠ‚æµ
```typescript
// æ‰‹åŠ¿é˜²æŠ–
const triggerGestureEvent = useCallback(
  debounce(async (type: GestureType, detail: GestureDetail) => {
    await PlatformService.triggerHapticFeedback(HapticFeedbackType.Light);
    onGesture({ type, detail });
  }, 500),
  [onGesture]
);

// çª—å£å¤§å°å˜åŒ–èŠ‚æµ
const handleResize = useCallback(
  throttle(() => {
    if (canvasRef.current && engineRef.current) {
      engineRef.current.resize();
    }
  }, 100),
  []
);
```

### 4. ä»£ç åˆ†å‰²

#### è·¯ç”±çº§åˆ†å‰²
```typescript
// æ‡’åŠ è½½é¡µé¢ç»„ä»¶
const Home = lazy(() => import('./pages/Home'));
const Settings = lazy(() => import('./pages/Settings'));

const App: React.FC = () => (
  <Suspense fallback={<LoadingSpinner />}>
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/settings" element={<Settings />} />
    </Routes>
  </Suspense>
);
```

#### ç»„ä»¶çº§åˆ†å‰²
```typescript
// æ‡’åŠ è½½é‡å‹ç»„ä»¶
const LazyCanvasBackground = lazy(() => import('./components/lazy/LazyCanvasBackground'));

const BackgroundRenderer: React.FC = () => {
  const shouldUseCanvas = useAppStoreSelectors.useIsCanvasTexture();
  
  return (
    <Suspense fallback={<div className="background-placeholder" />}>
      {shouldUseCanvas ? <LazyCanvasBackground /> : <DivBackground />}
    </Suspense>
  );
};
```

---

## ğŸ“± è·¨å¹³å°é€‚é…

### å¹³å°æ£€æµ‹ç³»ç»Ÿ

```typescript
// PlatformService.ts
export class PlatformService {
  // å¹³å°ç±»å‹æ£€æµ‹
  static getPlatform(): PlatformType {
    if (Capacitor.isNativePlatform()) {
      return Capacitor.getPlatform() === 'ios' ? PlatformType.iOS : PlatformType.Android;
    }
    return PlatformType.Web;
  }
  
  // è®¾å¤‡èƒ½åŠ›æ£€æµ‹
  static async detectCapabilities(): Promise<DeviceCapabilities> {
    return {
      platform: this.getPlatform(),
      deviceType: this.detectDeviceType(),
      isNative: this.isNative(),
      supportsHaptics: this.isNative(),
      supportsStatusBar: this.isNative(),
      hasNotch: this.detectNotch(),
      screenSize: this.getScreenSize(),
      safeArea: this.detectSafeArea()
    };
  }
}
```

### åŸç”ŸåŠŸèƒ½é›†æˆ

#### è§¦è§‰åé¦ˆ
```typescript
// è·¨å¹³å°è§¦è§‰åé¦ˆ
static async triggerHapticFeedback(type: HapticFeedbackType): Promise<void> {
  if (!this.isNative()) return; // Webå¹³å°è·³è¿‡
  
  try {
    switch (type) {
      case HapticFeedbackType.Light:
        await Haptics.impact({ style: ImpactStyle.Light });
        break;
      case HapticFeedbackType.Success:
        await Haptics.notification({ type: NotificationType.Success });
        break;
    }
  } catch (error) {
    logger.error('Haptic feedback failed:', error);
  }
}
```

#### æ–‡ä»¶ç³»ç»Ÿè®¿é—®
```typescript
// è·¨å¹³å°æ–‡ä»¶ä¿å­˜
static async saveFile(data: string, fileName: string): Promise<SaveResult> {
  try {
    if (!Capacitor.isNativePlatform()) {
      // Webå¹³å°ä½¿ç”¨ä¸‹è½½
      return this.saveFileWeb(data, fileName);
    }
    
    // åŸç”Ÿå¹³å°ä½¿ç”¨æ–‡ä»¶ç³»ç»ŸAPI
    const result = await Filesystem.writeFile({
      path: fileName,
      data: data,
      directory: Directory.Documents,
      encoding: Encoding.UTF8
    });
    
    return { success: true, fileName, path: result.uri };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}
```

### æ ·å¼é€‚é…

#### å®‰å…¨åŒºåŸŸé€‚é…
```scss
// _variables.scss
:root {
  --sat: env(safe-area-inset-top);
  --sab: env(safe-area-inset-bottom);
  --sal: env(safe-area-inset-left);
  --sar: env(safe-area-inset-right);
}

// é€‚é…åˆ˜æµ·å±
.home-page {
  padding-top: var(--sat);
  padding-bottom: var(--sab);
  padding-left: var(--sal);
  padding-right: var(--sar);
}

// iOSåˆ˜æµ·å±ç‰¹æ®Šå¤„ç†
@supports (padding: max(0px)) {
  .home-page {
    padding-top: max(20px, var(--sat));
    padding-bottom: max(20px, var(--sab));
  }
}
```

#### å“åº”å¼è®¾è®¡
```scss
// è®¾å¤‡æ–­ç‚¹
$breakpoints: (
  'mobile': 320px,
  'tablet': 768px,
  'desktop': 1024px
);

@mixin respond-to($device) {
  @media screen and (min-width: map-get($breakpoints, $device)) {
    @content;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
.color-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  
  @include respond-to('tablet') {
    grid-template-columns: repeat(4, 1fr);
  }
  
  @include respond-to('desktop') {
    grid-template-columns: repeat(6, 1fr);
  }
}
```

---

## ğŸ† æœ€ä½³å®è·µæ€»ç»“

### 1. æ¶æ„è®¾è®¡åŸåˆ™

#### åˆ†å±‚æ¶æ„
- **UIå±‚**ï¼šçº¯å±•ç¤ºç»„ä»¶ï¼Œä¸åŒ…å«ä¸šåŠ¡é€»è¾‘
- **å®¹å™¨å±‚**ï¼šç»„åˆä¸šåŠ¡é€»è¾‘å’ŒUIç»„ä»¶
- **Hookå±‚**ï¼šå°è£…å¯å¤ç”¨çš„ä¸šåŠ¡é€»è¾‘
- **æœåŠ¡å±‚**ï¼šæŠ½è±¡å¤–éƒ¨ä¾èµ–å’Œå¹³å°å·®å¼‚
- **çŠ¶æ€å±‚**ï¼šç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†

#### æ¨¡å—åŒ–è®¾è®¡
```typescript
// åŠŸèƒ½æ¨¡å—åŒ–
export const ColorModule = {
  components: {
    ColorCard,
    ColorGrid,
    ColorPicker
  },
  hooks: {
    useColorSelection,
    useColorHistory
  },
  services: {
    ColorService
  },
  types: {
    ColorCard,
    ColorType
  }
};
```

### 2. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### æ¸²æŸ“ä¼˜åŒ–
- **æ™ºèƒ½æ¸²æŸ“é€‰æ‹©**ï¼šæ ¹æ®è®¾å¤‡æ€§èƒ½å’Œçº¹ç†å¤æ‚åº¦é€‰æ‹©æ¸²æŸ“æ–¹æ¡ˆ
- **ç»„ä»¶ä¼˜åŒ–**ï¼šReact.memoã€useCallbackã€useMemo çš„åˆç†ä½¿ç”¨
- **æ‡’åŠ è½½**ï¼šé‡å‹ç»„ä»¶å’Œè·¯ç”±çš„æ‡’åŠ è½½

#### å†…å­˜ç®¡ç†
- **èµ„æºæ¸…ç†**ï¼šåŠæ—¶æ¸…ç† Canvasã€äº‹ä»¶ç›‘å¬å™¨ç­‰èµ„æº
- **ç¼“å­˜ç­–ç•¥**ï¼šå¸¦ TTL çš„æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ
- **é˜²æŠ–èŠ‚æµ**ï¼šé«˜é¢‘äº‹ä»¶çš„é˜²æŠ–å’ŒèŠ‚æµå¤„ç†

### 3. ç”¨æˆ·ä½“éªŒè®¾è®¡

#### äº¤äº’åé¦ˆ
- **è§¦è§‰åé¦ˆ**ï¼šå…³é”®æ“ä½œæä¾›è§¦è§‰åé¦ˆ
- **è§†è§‰åé¦ˆ**ï¼šåŠ¨ç”»å’ŒçŠ¶æ€å˜åŒ–çš„è§†è§‰åé¦ˆ
- **æ‰‹åŠ¿æ”¯æŒ**ï¼šç›´è§‚çš„æ‰‹åŠ¿æ“ä½œ

#### æ€§èƒ½æ„ŸçŸ¥
- **åŠ è½½çŠ¶æ€**ï¼šæ˜ç¡®çš„åŠ è½½æŒ‡ç¤ºå™¨
- **é”™è¯¯å¤„ç†**ï¼šå‹å¥½çš„é”™è¯¯æç¤ºå’Œæ¢å¤æœºåˆ¶
- **ç¦»çº¿æ”¯æŒ**ï¼šå…³é”®åŠŸèƒ½çš„ç¦»çº¿å¯ç”¨æ€§

### 4. ä»£ç è´¨é‡ä¿è¯

#### ç±»å‹å®‰å…¨
```typescript
// ä¸¥æ ¼çš„ç±»å‹å®šä¹‰
interface ColorCard {
  color: string;
  name?: string;
  zhName: string;
  pinyin?: string;
  description: string;
  year?: number;
}

// è”åˆç±»å‹ç¡®ä¿ç±»å‹å®‰å…¨
type ColorType = 'brand' | 'chinese' | 'nature' | 'food' | 'mood' | 'space';
type TextureType = 'solid' | 'linear' | 'paint' | 'frosted';
```

#### é”™è¯¯å¤„ç†
```typescript
// ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
export class ColorCardError extends Error {
  constructor(
    message: string,
    public code: string,
    public context?: any
  ) {
    super(message);
    this.name = 'ColorCardError';
  }
}

// é”™è¯¯è¾¹ç•Œ
export class ErrorBoundary extends Component<Props, State> {
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    logger.error('ErrorBoundary caught an error:', error, errorInfo);
    // é”™è¯¯ä¸ŠæŠ¥
    this.reportError(error, errorInfo);
  }
}
```

#### æµ‹è¯•ç­–ç•¥
```typescript
// å•å…ƒæµ‹è¯•ç¤ºä¾‹
describe('ColorService', () => {
  it('should convert hex to rgb correctly', () => {
    expect(hexToRgb('#FF6B6B')).toEqual({ r: 255, g: 107, b: 107 });
  });
  
  it('should calculate contrast color correctly', () => {
    expect(getContrastColor('#FFFFFF')).toBe('#000000');
    expect(getContrastColor('#000000')).toBe('#FFFFFF');
  });
});

// é›†æˆæµ‹è¯•ç¤ºä¾‹
describe('ColorSelection Hook', () => {
  it('should update color and trigger haptic feedback', async () => {
    const { result } = renderHook(() => useColorSelection());
    
    await act(async () => {
      result.current.changeColor('#FF6B6B');
    });
    
    expect(result.current.selectedColor).toBe('#FF6B6B');
    expect(mockHapticFeedback).toHaveBeenCalled();
  });
});
```

### 5. ç»´æŠ¤æ€§è®¾è®¡

#### é…ç½®é©±åŠ¨
```typescript
// é›†ä¸­é…ç½®ç®¡ç†
export const APP_CONFIG = {
  animation: {
    defaultDuration: 300,
    easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
  },
  colors: {
    maxHistoryItems: 50,
    maxFavorites: 100
  },
  performance: {
    maxMemoryUsage: 100, // MB
    minFrameRate: 30     // FPS
  }
};
```

#### æ–‡æ¡£åŒ–
- **æ¥å£æ–‡æ¡£**ï¼šå®Œæ•´çš„ TypeScript æ¥å£å®šä¹‰
- **ç»„ä»¶æ–‡æ¡£**ï¼šè¯¦ç»†çš„ç»„ä»¶ä½¿ç”¨è¯´æ˜
- **æ¶æ„æ–‡æ¡£**ï¼šç³»ç»Ÿæ¶æ„å’Œè®¾è®¡å†³ç­–è¯´æ˜

#### ç›‘æ§å’Œåˆ†æ
```typescript
// æ€§èƒ½ç›‘æ§
const performanceService = PerformanceService.getInstance({
  enableWebVitals: true,
  enableMemoryMonitoring: true,
  sampleRate: 0.1 // 10% é‡‡æ ·ç‡
});

// ç”¨æˆ·è¡Œä¸ºåˆ†æ
const trackUserAction = (action: string, context?: any) => {
  logger.info('User action:', action, context);
  // å‘é€åˆ°åˆ†ææœåŠ¡
};
```

---

## ğŸ“‹ æ€»ç»“

ColorCard é¡¹ç›®å±•ç¤ºäº†ç°ä»£ Web åº”ç”¨çš„æœ€ä½³å®è·µï¼š

### ğŸ—ï¸ æ¶æ„ä¼˜åŠ¿
1. **æ¸…æ™°çš„åˆ†å±‚æ¶æ„**ï¼šUIã€ä¸šåŠ¡é€»è¾‘ã€æœåŠ¡å±‚åˆ†ç¦»æ˜ç¡®
2. **æ¨¡å—åŒ–è®¾è®¡**ï¼šé«˜å†…èšã€ä½è€¦åˆçš„æ¨¡å—ç»„ç»‡
3. **æœåŠ¡åŒ–æŠ½è±¡**ï¼šå¤–éƒ¨ä¾èµ–çš„ç»Ÿä¸€æŠ½è±¡å’Œç®¡ç†

### ğŸš€ æŠ€æœ¯åˆ›æ–°
1. **æ™ºèƒ½åŒæ¸²æŸ“ç³»ç»Ÿ**ï¼šæ€§èƒ½å’ŒåŠŸèƒ½çš„å®Œç¾å¹³è¡¡
2. **å…ˆè¿›çŠ¶æ€ç®¡ç†**ï¼šåŸºäº Zustand çš„å“åº”å¼çŠ¶æ€æ¶æ„
3. **æµç•…äº¤äº’ä½“éªŒ**ï¼šæ‰‹åŠ¿æ§åˆ¶ã€è§¦è§‰åé¦ˆã€ç‰©ç†åŠ¨ç”»

### ğŸ’¡ å­¦ä¹ ä»·å€¼
1. **ç°ä»£ React å¼€å‘**ï¼šHooksã€å¹¶å‘ç‰¹æ€§ã€æ€§èƒ½ä¼˜åŒ–
2. **è·¨å¹³å°å¼€å‘**ï¼šWebã€iOSã€Android çš„ç»Ÿä¸€å¼€å‘ä½“éªŒ
3. **å·¥ç¨‹åŒ–å®è·µ**ï¼šTypeScriptã€æµ‹è¯•ã€ç›‘æ§ã€éƒ¨ç½²

è¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„åº”ç”¨ï¼Œæ›´æ˜¯ç°ä»£å‰ç«¯æ¶æ„è®¾è®¡çš„ä¼˜ç§€èŒƒä¾‹ï¼Œå€¼å¾—æ·±å…¥å­¦ä¹ å’Œå€Ÿé‰´ã€‚

---

*æœ¬æ•™ç¨‹è¯¦ç»†åˆ†æäº† ColorCard é¡¹ç›®çš„æ¶æ„è®¾è®¡ï¼Œå¸Œæœ›èƒ½å¸®åŠ©ä½ ç†è§£ç°ä»£ Web åº”ç”¨çš„è®¾è®¡æ€è·¯å’Œæœ€ä½³å®è·µã€‚å¦‚éœ€æ›´æ·±å…¥çš„äº†è§£æŸä¸ªç‰¹å®šéƒ¨åˆ†ï¼Œå»ºè®®ç»“åˆæºç è¿›è¡Œå­¦ä¹ ã€‚*